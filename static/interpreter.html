<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="description" content="Interpreter for annotated parse trees generated by Language.">
    <title>Interpreter</title>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js" type="text/javascript"></script>
    <script type="text/javascript" src="libs/handlebars-1.0.rc.1.js"></script>
    <script type="text/javascript" src="libs/jQuery-URL-Parser/purl.js"></script>
    <style>
    .category {
        color:blue;
    }
    .details {
        color:green;
    }
    .component {
        color:orange;
    }
    </style>
    <script>
    /*
    This is a universal (AFAIK) interpreter for Language languages.
    By default non-terminals return a list of their evaluated components.
    An "implementation" function can be provided in the production rule.
    Implementation functions take the evaluated components as arguements,
    and their "this" keyword is bound to the processed languageNode (which differs from the one in languageNode.json unfortunately).
    */
    Handlebars.registerHelper('stringify', function(object) {
        return JSON.stringify($.extend({}, object), 2, 4);
    });
    //Temporairy hack until I switch to lazy arrays (see below).
    Array.prototype.at = (function(){
        return function(idx) {
            return this[idx];
        };
    })();
    
    //TODO: Unit test this function.
    //This function might be tricky to make lazy.
    /**
     * Generate array combinations from left to right.
     * TODO: more detail
     **/
    function arrayCombinations(arrays, callback) {
        if(arrays.length > 0) {
            //Empty component arrays would probably cause a problem here.
            //I'm going to make them required. At the very least they should contain the empty string.
            if(arrays.at(0).length > 0){
                arrays.at(0).forEach(function(car){
                    arrayCombinations(arrays.slice(1), function(combination){
                        callback([car].concat(combination));
                    });
                });
            }
        } else {
            callback([])
        }
    }
    
    var tested = 0;
    arrayCombinations([[1]], function(combo) {
        tested++;
        console.assert(combo[0] === 1);
    });
    arrayCombinations([[1,2],[3]], function(combo) {
        tested++;
        console.assert(combo[1] === 3);
    });
    console.assert(tested === 3);

    /**
     * evaluate a languageNode and call the callback mulitple times with each interpretation.
     * I would like to make this lazy because I think short circuting could help
     * a lot with preventing needless enumeration of interpretations.
     * However, that turns out to be a tall order. I think it will require lazy arrays
     * with lazyMap and lazyFlatten functions. To support this I'm using an `at` function rather brackets.
     **/
    function evaluate(component, callback) {
        var callbackWithEvaledComps = function(components) {
            var componentEvaluator = function(components){return components;};
            if('content' in component) {
                if('implementation' in component.content) {
                    //console.log(component.content.implementation);
                    //TODO: Make this eval less evil.
                    componentEvaluator = eval('('+component.content.implementation+')');
                }
            }
            setTimeout(function() {
                try {
                    console.log(components);
                    callback(componentEvaluator.call(component, components));
                } catch (e) {
                    console.error(componentEvaluator);
                    console.error(component);
                    console.error(components);
                    //TODO: Add an error parameter to the evaluate callbacks.
                    throw e;
                }
            }, 0);
        };
        
        if('terminal' in component) {
            callbackWithEvaledComps([component.terminal]);
        } else if('match' in component) {
            //TODO: can there be multiple matches?
            callbackWithEvaledComps([component.match]);
        } else if('interpretations' in component) {
            //Q: Is it better for primative evaluation functions to take the unevaluated parse tree below them as an arg
            //or take the evaluated child nodes as an arg?
            //Taking the parse tree gives more control, but adds an additional function I have to call.
            //Actually calling the extra function doesn't sound bad,
            //but I think I would also have to handle interpretations in the primative evaluation functions,
            //which sounds really bad.
            component.interpretations.forEach(function(interpretation) {
                var componentsEvaluatedSoFar = interpretation.map(function(){return [];})
                function combinationGenerator(possibleValue, idx, callback) {
                    arrayCombinations(componentsEvaluatedSoFar.slice(0,idx), function(leftCombo){
                        arrayCombinations(componentsEvaluatedSoFar.slice(idx + 1), function(rightCombo){
                            callback(leftCombo.reverse().concat([possibleValue]).concat(rightCombo))
                        });
                    });
                }
                interpretation.forEach(function(component, idx) {
                    evaluate(component, function(possibleValue) {
                        combinationGenerator(possibleValue, idx, function(combination){
                            callbackWithEvaledComps(combination);
                        });
                        //I'm worrying about a callback order problem here.
                        componentsEvaluatedSoFar[idx].push(possibleValue);
                    });
                });
            });
        } else {
            console.error(component);
            throw new Error('?');
        }
    }
    
    $(function() {
        var interpId = $.url().param('interpId');
        $.getJSON('../interpretations/' + interpId, function(data) {
            console.log(JSON.stringify(data.root));
            //TODO: Where should the evaluation start?
            evaluate(data.root.interpretations[0][0], function(interpretation) {
                var $p = $('<p>');
                $p.text(JSON.stringify(interpretation));
                $('.content').append($p);
            });
        });
    });
    </script>
</head>
<body>
    <div class="content"></div>
</body>
</html>