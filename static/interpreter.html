<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="description" content="Interpreter for annotated parse trees generated by Language.">
    <title>Interpreter</title>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js" type="text/javascript"></script>
    <script type="text/javascript" src="libs/handlebars-1.0.rc.1.js"></script>
    <script type="text/javascript" src="libs/jQuery-URL-Parser/purl.js"></script>
    <style>
    .category {
        color:blue;
    }
    .details {
        color:green;
    }
    .component {
        color:orange;
    }
    </style>
    <script>
    /*
    This is a universal (AFAIK) interpreter for Language languages.
    By default non-terminals return a list of their evaluated components.
    An "implementation" function can be provided in the production rule.
    Implementation functions take the evaluated components as arguements,
    and their "this" keyword is bound to the processed languageNode (which differs from the one in languageNode.json unfortunately).
    */
    Handlebars.registerHelper('stringify', function(object) {
        return JSON.stringify($.extend({}, object), 2, 4);
    });
    //Temporairy hack until I switch to lazy arrays (see below).
    Array.prototype.at = (function(){
        return function(idx) {
            return this[idx];
        };
    })();
    
    //TODO: Unit test this function.
    //This function might be tricky to make lazy.
    /**
     * Generate array combinations from left to right.
     * TODO: more detail
     **/
    function arrayCombinations(arrays, callback) {
        if(arrays.length > 0) {
            //Empty component arrays would probably cause a problem here.
            //I'm going to make them required. At the very least they should contain the empty string.
            if(arrays.at(0).length > 0){
                arrays.at(0).forEach(function(car){
                    arrayCombinations(arrays.slice(1), function(combination){
                        callback([car].concat(combination));
                    });
                });
            }
        } else {
            callback([])
        }
    }
    
    var tested = 0;
    arrayCombinations([[1]], function(combo) {
        tested++;
        console.assert(combo[0] === 1);
    });
    arrayCombinations([[1,2],[3]], function(combo) {
        tested++;
        console.assert(combo[1] === 3);
    });
    console.assert(tested === 3);

    /**
     * evaluate a languageNode and call the callback mulitple times with each interpretation.
     * I would like to make this lazy because I think short circuting could help
     * a lot with preventing needless enumeration of interpretations.
     * However, that turns out to be a tall order. I think it will require lazy arrays
     * with lazyMap and lazyFlatten functions. To support this I'm using an `at` function rather brackets.
     **/
    function evaluate(component, callback) {
        /**
         * Evalutae the given array of components (possibly using the function
         * specified by the current component) and pass the result into the callback function.
         **/
        var evalThenCallback = function(components) {
            //Q: Is it better for components to be evaluated prior to being passed into this function?
            //Unevaluated compoents give the componentEvaluator more control over performance,
            //although dealing with multiple interpretations in componentEvaluator functions
            //seems like it would be a headache.
            var componentEvaluator = function(components){return components;};
            if('content' in component) {
                if('implementation' in component.content) {
                    //console.log(component.content.implementation);
                    //TODO: Make this eval less evil.
                    //The componentEvaluator's `this` keyword is bound to the component,
                    //so the full parseTree is available to it through this.interpretations.
                    componentEvaluator = eval('('+component.content.implementation+')');
                }
            }
            setTimeout(function() {
                try {
                    console.log(components);
                    callback(componentEvaluator.call(component, components));
                } catch (e) {
                    console.error(componentEvaluator);
                    console.error(component);
                    console.error(components);
                    //TODO: Add an error parameter to the evaluate callbacks.
                    throw e;
                }
            }, 0);
        };
        
        if('terminal' in component) {
            evalThenCallback([component.terminal]);
        } else if('match' in component) {
            //TODO: can there be multiple matches?
            evalThenCallback([component.match]);
        } else if('interpretations' in component) {
            component.interpretations.forEach(function(interpretation) {
                var componentsEvaluatedSoFar = interpretation.map(function(){return [];});
                interpretation.forEach(function(component, idx) {
                    evaluate(component, function(possibleValue) {
                        //Generate all the possible combinations of values so far.
                        arrayCombinations(componentsEvaluatedSoFar.slice(0,idx), function(leftCombo){
                            arrayCombinations(componentsEvaluatedSoFar.slice(idx + 1), function(rightCombo){
                                var combination = leftCombo.concat([possibleValue]).concat(rightCombo);
                                evalThenCallback(combination);
                            });
                        });
                        //I'm worrying about a callback order problem here.
                        componentsEvaluatedSoFar[idx].push(possibleValue);
                    });
                });
            });
        } else {
            console.error(component);
            throw new Error('?');
        }
    }
    
    $(function() {
        var interpId = $.url().param('interpId');
        $.getJSON('../interpretations/' + interpId, function(data) {
            console.log(JSON.stringify(data.root));
            //TODO: Where should the evaluation start?
            evaluate(data.root.interpretations[0][0], function(interpretation) {
                var $p = $('<p>');
                $p.text(JSON.stringify(interpretation));
                $('.content').append($p);
            });
        });
    });
    </script>
</head>
<body>
    <div class="content"></div>
</body>
</html>