<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="description" content="Interpreter for annotated parse trees generated by Language.">
    <title>Interpreter</title>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js" type="text/javascript"></script>
    <script type="text/javascript" src="libs/handlebars-1.0.rc.1.js"></script>
    <script type="text/javascript" src="libs/jQuery-URL-Parser/purl.js"></script>
    <style>
    .category {
        color:blue;
    }
    .details {
        color:green;
    }
    .component {
        color:orange;
    }
    </style>
    <script>
    /*
    This is a universal (AFAIK) interpreter for Language languages.
    By default non-terminals return a list of their evaluated components.
    An "implementation" function can be provided in the production rule.
    Implementation functions take the evaluated components as arguements,
    and their "this" keyword is bound to the processed languageNode (which differs from the one in languageNode.json unfortunately).
    */
    Handlebars.registerHelper('stringify', function(object) {
        return JSON.stringify($.extend({}, object), 2, 4);
    });
    //TODO: Unit test this function.
    function arrayCombinations(arrays) {
        var combinations = [];
        var restCombos;
        if(arrays.length > 1) {
            restCombos = arrayCombinations(arrays.slice(1));
            if(arrays[0].length == 0){
                //Empty component arrays cause lots of edge cases.
                //Maybe they should be considered invalid?
                combinations.push(restCombos);
                return;
            }
            arrays[0].forEach(function(car){
                restCombos.forEach(function(combination) {
                    combinations.push([car].concat(combination));
                });
            });
        } else {
            combinations = arrays[0].map(function(car){
                return [car];
            });
        }
        return combinations;
    }
    console.assert(arrayCombinations([[1]])[0][0]===1);
    //TODO: Test getJSONPath/setJSONPath. BTW they aren't used in here.
    function getJSONPath(object, path, defaultValue) {
        if(typeof path == "string") {
            path = path.split('.');
        }
        var pathComponent = path[0];
        if(path.length === 1){
            return (pathComponent in object) ? object[pathComponent] : defaultValue;
        } else {
            if( !(pathComponent in object) || (typeof object[pathComponent] != "object")) {
                return defaultValue
            }
            return setJSONPath(object[pathComponent], path.slice(1), defaultValue)
        }
    }
    function setJSONPath(object, path, value) {
        if(typeof path == "string") {
            path = path.split('.');
        }
        var pathComponent = path[0];
        if(path.length === 1){
            object[pathComponent] = value;
        } else {
            if( !(pathComponent in object) || (typeof object[pathComponent] != "object")) {
                object[pathComponent] = {};
            }
            setJSONPath(object[pathComponent], path.slice(1), value)
        }
    }
    function evaluate(component) {
        var componentEvaluator = function(components){return components;};
        var outInterps = [];
        
        if('content' in component) {
            if('implementation' in component.content) {
                //console.log(component.content.implementation);
                componentEvaluator = eval('('+component.content.implementation+')');
            }
        }
        
        
        if('terminal' in component) {
            outInterps = [component.terminal];
        } else if('match' in component) {
            //TODO: can there be multiple matches?
            outInterps = [component.match];
        } else if('interpretations' in component) {
            
            //Q: Is it better for primative evaluation functions to take the unevaluated parse tree below them as an arg
            //or take the evaluated child nodes as an arg?
            //Taking the parse tree gives more control, but adds an additional function I have to call.
            //Actually calling the extra function doesn't sound bad,
            //but I think I would also have to handle interpretations in the primative evaluation functions,
            //which sounds really bad.
            component.interpretations = component.interpretations.map(function(interpretation) {
                //TODO: Make this lazy
                return {
                    components : interpretation,
                    evaluatedComponents : interpretation.map(evaluate),
                };
            });
            component.interpretations.forEach(function(interpretation) {
                //console.error(interpretation.evaluatedComponents);
                var evaledComponentsInterps = arrayCombinations(interpretation.evaluatedComponents);
                //console.error(evaledComponentsInterps);
                outInterps = outInterps.concat(evaledComponentsInterps);
            });
        } else {
            console.error(component);
            throw new Error('?');
        }
        console.log(outInterps);
        /*
        console.log(outInterps.map(function(interpretation){
            return componentEvaluator.call(component, interpretation);
        }));*/
        return outInterps.map(function(interpretation){
            return componentEvaluator.call(component, interpretation);
        });
    }
    
    $(function() {
        
        var interpId = $.url().param('interpId');
        $.getJSON('../interpretations/' + interpId, function(data) {
            console.log(JSON.stringify(data.root));
            //TODO: Where should the evaluation start?
            evaluate(data.root.interpretations[0][0]).forEach(function(interpretation) {
                var $p = $('<p>');
                $p.text(JSON.stringify(interpretation));
                $('.content').append($p);
            });
        });
        /*
        console.log('X');
        console.log(evaluate({"interpretations":[[{"parseData":{"atComponent":3,"stringIdx":0,"origin":0},"interpretations":[[{"terminal":"("},{"interpretations":[[{"parseData":{"atComponent":1,"stringIdx":0,"origin":1},"interpretations":[[{"regex":"\\d+(\\.\\d+)?","compiledRegExp":{},"match":"1"}]],"_id":"508da1d014a8fca63f610c57","content":{"category":"s_exp","components":[{"regex":"\\d+(\\.\\d+)?","compiledRegExp":{}}]},"lastSync":"Sun Oct 28 2012 17:21:20 GMT-0400 (EDT)","repository":{"type":"gist","gistId":"3969897"},"category":"s_exp","components":[{"regex":"\\d+(\\.\\d+)?","compiledRegExp":{}}]},{"terminal":" "},{"interpretations":[[{"parseData":{"atComponent":1,"stringIdx":0,"origin":3},"interpretations":[[{"regex":"\\d+(\\.\\d+)?","compiledRegExp":{},"match":"1"}]],"_id":"508da1d014a8fca63f610c57","content":{"category":"s_exp","components":[{"regex":"\\d+(\\.\\d+)?","compiledRegExp":{}}]},"lastSync":"Sun Oct 28 2012 17:21:20 GMT-0400 (EDT)","repository":{"type":"gist","gistId":"3969897"},"category":"s_exp","components":[{"regex":"\\d+(\\.\\d+)?","compiledRegExp":{}}]}]],"parseData":{"atComponent":1,"stringIdx":0,"origin":3},"_id":"508dd3a614a8fca63f610c5c","content":{"category":"s_list","components":[{"category":"s_exp"}]},"lastSync":"Sun Oct 28 2012 20:53:58 GMT-0400 (EDT)","repository":{"type":"gist","gistId":"3970764"},"category":"s_list","components":[{"category":"s_exp"}]}]],"parseData":{"atComponent":3,"stringIdx":0,"origin":1},"_id":"508da1b414a8fca63f610c55","content":{"category":"s_list","components":[{"category":"s_exp"}," ",{"category":"s_list"}]},"lastSync":"Sun Oct 28 2012 17:20:52 GMT-0400 (EDT)","repository":{"type":"gist","gistId":"3969884"},"category":"s_list","components":[{"category":"s_exp"},{"terminal":" "},{"category":"s_list"}]},{"terminal":")"}]],"_id":"508da1c114a8fca63f610c56","content":{"category":"s_exp","components":["(",{"category":"s_list"},")"],"implementation":"listImpl"},"lastSync":"Sun Nov 04 2012 15:38:54 GMT-0500 (EST)","repository":{"type":"gist","gistId":"3969887"},"category":"s_exp","components":[{"terminal":"("},{"category":"s_list"},{"terminal":")"}]}]],"parseData":{"atComponent":1,"stringIdx":0,"origin":0},"_id":"508c4d5714a8fca63f610c47","content":{"category":"main","components":[{"category":"s_exp"}],"url":"/interpreter.html"},"lastSync":"Sun Nov 04 2012 15:38:05 GMT-0500 (EST)","repository":{"type":"gist","gistId":"3966264"},"category":"main","components":[{"category":"s_exp"}]} ));
        */
    });
    </script>
</head>
<body>
    <div class="content"></div>
</body>
</html>